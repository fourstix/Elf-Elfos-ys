                        ; -------------------------------------------------------------------
                        ; -------------------------------------------------------------------
                        ; *** ys: send one or more files using YMODEM batch protocol
                        ; ***
                        ; *** Build #
                        ; ***  1: Proof of concept version
                        ; ***  2: First bug squashed: 256 & 512 byte files were sent 
                        ; ***     as 0 bytes
                        ; ***  3: Added file timestamp to block 0
                        ; ***  4: Inlined some Tx/Rx code to make it fast enough to
                        ; ***     catch the ACK & CRC/NAK at the end of a block send
                        ; ***  5: Dec/hex oops in "Couldn't open file:" message
                        ; ***  6: missed a "pop rc" when O_READ didn't read any bytes
                        ; ***  7: moved endrom to end of uninitialised data so that
                        ; ***     Elf/OS 0.4.x can tell if we're colliding with the heap.
                        ; ***     Make stack manipulation interrupt safe on entry and
                        ; ***     exit (even though soft UART code is unlikely to work
                        ; ***     if interrupted).
                        ; *******************************************************************
                        ; *** This software is released to the public domain.		  ***
                        ; *** You have permission to use, modify, copy, and distribute	  ***
                        ; *** this software as you please.				  ***
                        ; *******************************************************************
                        ;
                        ; Register usage:
                        ;
                        ; System:
                        ;   r0   - Resesrved for DMA
                        ;   r1   - Reserved for interrupts
                        ;   r2   - Stack pointer
                        ;   r3   - Program counter
                        ;   r4   - SCALL program counter
                        ;   r5   - SRET program counter
                        ;   r6   - SCALL return address
                        ;   re.0 - SCALL overwrites with D
                        ;   re.1 - Baud rate constant
                        ;
                        ; Main program :
                        ;
                        ;   ra   - Command line pointer (on exec)
                        ;
                        ; All other registers are available for subroutines.
                        ;
                        	include	"bios.inc"
                        ; *******************************************************************
                        ; *** This software is copyright 2006 by Michael H Riley		***
                        ; *** You have permission to use, modify, copy, and distribute	***
                        ; *** this software so long as this copyright notice is retained. ***
                        ; *** This software may not be used in commercial applications	***
                        ; *** without express written permission from the author.	 ***
                        ; *******************************************************************
                        
                        ; f_getdev bit values
                        
                        b_devIDE	equ	00000001b	; IDE
                        b_devFLPY	equ	00000010b	; floppy
                        b_devBBSER	equ	00000100b	; Bit-banged serial
                        b_devUART	equ	00001000b	; UART
                        b_devRTC	equ	00010000b	; RTC
                        b_devNVR	equ	00100000b	; NVRAM
                        
                        #ifndef _IS_BIOS
                        
                        ; Define address for standard BIOS vectors
                        BIOS	equ	0ff00h
                        
                        ; Define address for extended BIOS vectors
                        EBIOS	equ	0f800h
                        
                        scall	equ	r4			; register for SCALL
                        sret	equ	r5			; register for SRET
                        
                        f_boot		equ	(BIOS+00h)	; boot from ide device
                        f_type		equ	(BIOS+03h)	; type 1 character to console
                        f_read		equ	(BIOS+06h)	; read 1 character from console
                        f_msg		equ	(BIOS+09h)	; type asciiz string to console
                        f_typex		equ	(BIOS+0ch)	; depricated, just returns now
                        f_input		equ	(BIOS+0fh)	; read asciiz from console
                        f_strcmp	equ	(BIOS+12h)	; compare 2 strings
                        f_ltrim		equ	(BIOS+15h)	; trim leading spaces
                        f_strcpy	equ	(BIOS+18h)	; copy an asciiz string
                        f_memcpy	equ	(BIOS+1bh)	; copy memory
                        f_wrtsec	equ	(BIOS+1eh)	; write floppy sector (depricated)
                        f_rdsec		equ	(BIOS+21h)	; read floppy sector (depricated)
                        f_seek0		equ	(BIOS+24h)	; floppy seek to track 0 (depricated)
                        f_seek		equ	(BIOS+27h)	; floopy track seek (depricated)
                        f_drive		equ	(BIOS+2ah)	; select floppy drive (depricated)
                        f_setbd		equ	(BIOS+2dh)	; set console baud rate
                        f_mul16		equ	(BIOS+30h)	; 16-bit multiply
                        f_div16		equ	(BIOS+33h)	; 16-bit division
                        f_idereset	equ	(BIOS+36h)	; reset ide device
                        f_idewrite	equ	(BIOS+39h)	; write ide sector
                        f_ideread	equ	(BIOS+3ch)	; read ide sector
                        f_initcall	equ	(BIOS+3fh)	; initialize R4 and R5
                        f_bootide	equ	(BIOS+42h)	; boot from ide device
                        f_hexin		equ	(BIOS+45h)	; convert ascii number to hex
                        f_hexout2	equ	(BIOS+48h)	; convert hex to 2-digit ascii
                        f_hexout4	equ	(BIOS+4bh)	; convert hex to 4-digit ascii
                        f_tty		equ	(BIOS+4eh)	; type character to console
                        f_mover		equ	(BIOS+51h)	; program relocator
                        f_minimon	equ	(BIOS+54h)	; mini monitor
                        f_freemem	equ	(BIOS+57h)	; determine memory size
                        f_isnum		equ	(BIOS+5ah)	; determine if D is numeric
                        f_atoi		equ	(BIOS+5dh)	; convert ascii to integer
                        f_uintout	equ	(BIOS+60h)	; convert unsigned integer to ascii
                        f_intout	equ	(BIOS+63h)	; convert signed integer to ascii
                        f_inmsg		equ	(BIOS+66h)	; type in-line message
                        f_inputl	equ	(BIOS+69h)	; read limited line from console
                        f_brktest	equ	(BIOS+6ch)	; check for serial break
                        f_findtkn	equ	(BIOS+6fh)	; find token in a token table
                        f_isalpha	equ	(BIOS+72h)	; determine if D is alphabetic
                        f_ishex		equ	(BIOS+75h)	; determine if D is hexadecimal
                        f_isalnum	equ	(BIOS+78h)	; determine if D is alpha or numeric
                        f_idnum		equ	(BIOS+7bh)	; determine type of ascii number
                        f_isterm	equ	(BIOS+7eh)	; determine if D is a termination char
                        f_getdev	equ	(BIOS+81h)	; get supported devices
                        
                        f_version	equ	(BIOS+0f9h)	; 3 bytes holding bios version number
                        
                        ; "Extended" BIOS vectors
                        
                        f_bread		equ	(EBIOS+00h)	; read from onboard serial port
                        f_btype		equ	(EBIOS+03h)	; write to onboard serial port
                        f_btest		equ	(EBIOS+06h)	; test onboard serial port
                        f_utype		equ	(EBIOS+09h)	; write to disk board UART
                        f_uread		equ	(EBIOS+0ch)	; read from disk board UART
                        f_utest		equ	(EBIOS+0fh)	; test disk board UART
                        f_usetbd	equ	(EBIOS+12h)	; set disk board UART baud rate and format
                        f_gettod	equ	(EBIOS+15h)	; read time of day clock
                        f_settod	equ	(EBIOS+18h)	; set time of day clock
                        f_rdnvr		equ	(EBIOS+1bh)	; read non volatile RAM
                        f_wrnvr		equ	(EBIOS+1eh)	; write non volatile RAM
                        f_idesize	equ	(EBIOS+21h)	; return size of attached IDE drive(s)
                        f_ideid		equ	(EBIOS+24h)	; return device data for IDE drive(s)
                        f_tmtoas	equ	(EBIOS+2ah)	; time to ASCII string
                        f_dttoas	equ	(EBIOS+27h)	; date to ASCII string
                        f_rtctest	equ	(EBIOS+2dh)	; test size and presence of RTC/NVR
                        f_astodt	equ	(EBIOS+30h)	; convert ASCII string to date
                        f_astotm	equ	(EBIOS+33h)	; convert ASCII string to time
                        f_nvrcchk	equ	(EBIOS+36h)	; compute NVR checksum
                        
                        #endif
                        
                        	include	"kernel.inc"
                        O_CLDBOOT: equ     0300h               ; jump to cold boot routine
                        O_WRMBOOT: equ     0303h               ; jump to warm boot routine
                        O_OPEN:    equ     0306h               ; open a file
                        O_READ:    equ     0309h               ; read from file
                        O_WRITE:   equ     030ch               ; write to file
                        O_SEEK:    equ     030fh               ; seek to file position
                        O_CLOSE:   equ     0312h               ; close file
                        O_OPENDIR: equ     0315h               ; open dir as a file
                        O_DELETE:  equ     0318h               ; delete a file
                        O_RENAME:  equ     031bh               ; rename a file
                        O_EXEC:    equ     031eh               ; execute an external program
                        O_MKDIR:   equ     0321h               ; make directory
                        O_CHDIR:   equ     0324h               ; change directory
                        O_RMDIR:   equ     0327h               ; remove directory
                        O_RDLUMP:  equ     032Ah               ; read LAT entry
                        O_WRLUMP:  equ     032Dh               ; write LAT entry
                        O_TYPE:    equ     0330h               ; passthrough for console output
                        O_MSG:     equ     0333h               ; passthrough for console output
                        O_READKEY: equ     0336h               ; passthrough for console input
                        O_INPUT:   equ     0339h               ; passthrough for console input
                        O_PRTSTAT: equ     033ch               ; printer status
                        O_PRINT:   equ     033fh               ; output to printer
                        O_EXECBIN: equ     0342h               ; execute from default directory
                        O_SETDEF:  equ     0345h               ; set/get default directory
                        O_KINIT:   equ     0348h               ; reserved - do not use!!!
                        O_INMSG:   equ     034bh               ; passthrough for console output
                        O_GETDEV:  equ     034eh               ; passthrough to f_getdef
                        O_GETTOD:  equ     0351h               ; passthrough to f_gettod
                        O_SETTOD:  equ     0354h               ; passthrough to f_settod
                        O_INPUTL:  equ     0357h               ; passthrough to f_inputl
                        O_BOOT:    equ     035ah               ; passthrough to f_boot
                        O_SETBD:   equ     0360h               ; passthrough to f_setbd
                        O_INITCALL: equ    0363h               ; passthrough to f_initcall
                        O_BRKTEST: equ     0366h               ; passthrough to f_brktest
                        O_DEVCTRL: equ     0369h               ; Hook for device control drivers
                        O_ALLOC:   equ     036ch               ; passthrough to alloc
                        O_DEALLOC: equ     036fh               ; passthrough to dealloc
                        O_TERMCTRL: equ    0372h               ; Hook for terminal control drivers
                        O_MEMCTRL: equ     0375h               ; Hook for memory control drivers
                        I_SERVE:   equ     03f6h               ; address of interrupt chain head
                        V_IVEC:    equ     03fdh               ; interrupt head
                        V_DVEC:    equ     036ah               ; device head
                        K_VER:     equ     0400h               ; kernel version number
                        K_BUILD:   equ     0403h               ; kernel build number
                        K_BMONTH:  equ     0405h               ; kernel build month
                        K_BDAY:    equ     0406h               ; kernel build day
                        K_BYEAR:   equ     0407h               ; kernel build month
                        K_HIMEM:   equ     0442h               ; high memory pointer
                        K_LOWMEM:  equ     0465h               ; lowest memory heap can use
                        K_RETVAL:  equ     0467h               ; D on program exit
                        K_HEAP:    equ     0468h               ; heap pointer
                        K_CLKFREQ: equ     0470h               ; system clock frequency
                        K_MONTH:   equ     0475h               ; date/time
                        K_DAY:     equ     0476h
                        K_YEAR:    equ     0477h
                        K_HOUR:    equ     0478h
                        K_MINUTE:  equ     0479h
                        K_SECOND:  equ     047ah
                        K_SECDEN:  equ     047bh
                        K_SECNUM:  equ     047dh
                        ;
                        ;O_HIMEM:   equ     0442h               ; himem value
                        O_DATTIM:  equ     0475h               ; date/time block
                        ;
                        errexists: equ     1
                        errnoffnd: equ     2
                        errinvdir: equ     3
                        errisdir:  equ     4
                        errdirnotempty: equ   5
                        errnotexec:     equ   6
                        ;
                        O_CREAT	equ	00000001b
                        O_TRUNC	equ	00000010b
                        O_APPND	equ	00000100b
                        
                        ;	
                        debug	equ	0
                        ;
                        ; ***************************************************
                        ; ***** Constants				*****
                        ; ***************************************************
                        cr	equ	'M'-'@'
                        lf	equ	'J'-'@'
                        bs	equ	'H'-'@'
                        ;
                        soh	equ	'A'-'@'		; 128 byte packet header
                        stx	equ	'B'-'@'		; 1K byte packet header
                        eot	equ	'D'-'@'		; end of file transfer marker
                        ack	equ	'F'-'@'		; Acknowledge (good packet)
                        nak	equ	'U'-'@'		; Negative acknowledge (bad packet)
                        can	equ	'X'-'@'		; cancel transfer
                        crc	equ	'C'		; use CRC rather than checksum
                        ;
                        ; ***************************************************
                        ; ***** This block is the Execution header for	*****
                        ; ***** a stand-alone program. It begins 6	*****
                        ; *****bytes before the program start.		*****
                        ; ***************************************************
                        LoadAdr	equ	2000h
                        	org	LoadAdr-6	; Header starts at 01ffah
   1ffa   20 00         	dw	LoadAdr
   1ffc   10 1e         	dw	EndRom-LoadAdr
   1ffe   20 00         	dw	LoadAdr
                        ;
                        ; ***************************************************
                        ; ***** Code start				*****
                        ; ***************************************************
   2000   30 4a         	br	Start
                        ;
                        ; ***************************************************
                        ; ***** Program header				*****
                        ; ***************************************************
   2002   88 01 07 e5   	date
   2006   00 07         Build:	dw	7		; build number
   2008   62 69 74 20   	db	'bit banged UART on Q/EF2, inverted',0
   200c   62 61 6e 67   
   2010   65 64 20 55   
   2014   41 52 54 20   
   2018   6f 6e 20 51   
   201c   2f 45 46 32   
   2020   2c 20 69 6e   
   2024   76 65 72 74   
   2028   65 64 00      
                        ;
                        ;
                        monthDays:
   202b   1f 1c 1f 1e   	db	31,28,31,30,31,30,31,31,30,31,30,31
   202f   1f 1e 1f 1f   
   2033   1e 1f 1e 1f   
                        ;
   2037   00 00 00 00   FilDes:	db	0,0,0,0		; current file offset
   203b   29 00         	dw	Dta		; DTA
   203d   00 00         	dw	0		; eof
   203f   00            	db	0		; flags
   2040   00 00 00 00   sector:	db	0,0,0,0		; dir sector
   2044   00 00         dirofs:	dw	0		; dir offset
   2046   00 00 00 00   	db	0,0,0,0		; current sector in DTA
                        ;
                        ; ***************************************************
                        ; ***** Main program				*****
                        ; ***************************************************
                        start:	
   204a   86 73 96 73   	push	r6		; save Elf/OS's return address on its stack
   204e   f8 01         	ldi     1		; assume interrupts are enabled
   2050   cc            	lsie			; skip if they are
   2051   f8 00         	ldi	0		; mark interrupts disabled
   2053   ae            	plo	re		; save IE flag
   2054   f8 23         	ldi	023h		; setup for DIS (X=2, P=3)
   2056   52            	str	r2
   2057   71            	dis			; disable interrupts
   2058   22            	dec	r2
   2059   f8 2b bf f8   	load	rf,saveStack	; save Elf/OS's stack
   205d   8c af         
   205f   92            	ghi	r2
   2060   5f            	str	rf
   2061   1f            	inc	rf
   2062   82            	glo	r2
   2063   5f            	str	rf
   2064   f8 2b b2 f8   	load	r2,localStack	; use our own stack
   2068   8b a2         
   206a   8e            	glo	re		; recover IE flag
   206b   c2 20 73      	lbz	start2		; jump if interrupts were disabled
   206e   f8 23         	ldi	023h		; setup for RET (X=2, P=3)
   2070   52            	str	r2
   2071   70            	ret			; re-enable interrupts
   2072   22            	dec	r2
                        start2:
   2073   9e            	ghi	re		; turn off console echo
   2074   fa fe         	ani	11111110b
   2076   be            	phi	re
                        ;
   2077   d4 20 dc      	call	NextFileName	; point to first file name
   207a   ca 20 a6      	lbnz	NextFile	; and go send it
   207d   d4 03 4b      	call	O_INMSG		; otherwise display usage message
   2080   55 73 61 67   	db	'Usage:	ys filename [filename...]',cr,lf,0
   2084   65 3a 09 79   
   2088   73 20 66 69   
   208c   6c 65 6e 61   
   2090   6d 65 20 5b   
   2094   66 69 6c 65   
   2098   6e 61 6d 65   
   209c   2e 2e 2e 5d   
   20a0   0d 0a 00      
   20a3   c0 20 e5      	lbr	Exit		; and return to os
                        NextFile:
   20a6   d4 21 0d      	call	SendFile	; send next file
   20a9   d4 20 dc      	call	NextFileName	; point to next file name in cmd tail
   20ac   ca 20 a6      	lbnz	NextFile	; loop for next file
   20af   d4 24 4a      	call	WaitNAKorCRC
   20b2   f8 2d bf f8   	load	rf,blknum
   20b6   98 af         
   20b8   f8 00         	ldi	0
   20ba   5f            	str	rf
   20bb   d4 24 15      	call	ZeroBlock0	; send zero filled block 0 to finish up
                        	 if	debug=0
   20be   f8 25 bf f8   	load	rf,AckedAction
   20c2   44 af         
   20c4   f8 81         	ldi	low nextBlock
   20c6   5f            	str	rf
                        	 endi
   20c7   f8 2d bf f8   	load	rf,block0
   20cb   9e af         
   20cd   f8 00 bc f8   	load	rc,128
   20d1   80 ac         
   20d3   f8 0a         	ldi	10
   20d5   a8            	plo	r8
   20d6   d4 24 8f      	call	SendBlock
   20d9   c0 20 e5      	lbr	Exit		; and return to os
                        ;
                        ; ***************************************************
                        ; ***** NextFilename: advance RA to the next	*****
                        ; ***** non space character			*****
                        ; ***************************************************
                        NextFileName:
   20dc   4a            	lda	ra		; move past any spaces
   20dd   ff 20         	smi	' '
   20df   c2 20 dc      	lbz	NextFileName
   20e2   2a            	dec	ra		; move back to non-space character
   20e3   0a            	ldn	ra		; get byte
   20e4   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Exit: return to Elf/OS, restoring OS	*****
                        ; *****       stack and R6 contents		*****
                        ; ***************************************************
                        Exit:
   20e5   9e            	ghi	re		; restore console echo
   20e6   f9 01         	ori	00000001b
   20e8   be            	phi	re
   20e9   f8 01         	ldi     1		; assume interrupts are enabled
   20eb   cc            	lsie			; skip if they are
   20ec   f8 00         	ldi	0		; mark interrupts disabled
   20ee   ae            	plo	re		; save IE flag
   20ef   f8 23         	ldi	023h		; setup for DIS (X=2, P=3)
   20f1   52            	str	r2
   20f2   71            	dis			; disable interrupts
   20f3   22            	dec	r2
   20f4   f8 2b bf f8   	load	rf,saveStack	; restore Elf/OS's stack
   20f8   8c af         
   20fa   4f            	lda	rf
   20fb   b2            	phi	r2
   20fc   0f            	ldn	rf
   20fd   a2            	plo	r2
   20fe   8e            	glo	re		; recover IE flag
   20ff   c2 21 07      	lbz	Exit2		; jump if interrupts were disabled
   2102   f8 23         	ldi	023h		; setup for RET (X=2, P=3)
   2104   52            	str	r2
   2105   70            	ret			; re-enable interrupts
   2106   22            	dec	r2
                        Exit2:
   2107   60 72 b6 f0   	pop	r6		; restore Elf/OS's return address
   210b   a6            
   210c   d5            	retn			; return to Elf/OS
                        ;
                        ; ***************************************************
                        ; ***** Send file: send a single file	  	*****
                        ; ***** RA: points to file name			*****
                        ; ***************************************************
                        SendFile:
   210d   d4 24 15      	call	ZeroBlock0
   2110   f8 2d bd f8   	load	rd,block0	; copy filename to block
   2114   9e ad         
                        B0loop1:
   2116   4a            	lda	ra		; look for first less <= space
   2117   5d            	str	rd
   2118   1d            	inc	rd
   2119   ff 21         	smi	' '+1
   211b   c3 21 16      	lbdf	B0loop1
   211e   2a            	dec	ra
   211f   2d            	dec	rd
   2120   f8 00         	ldi	0		; zero terminate filename
   2122   5d            	str	rd
   2123   1d            	inc	rd
   2124   8d 73 9d 73   	push	rd		; save block ptr
   2128   f8 20 bd f8   	load	rd,fildes	; get file descriptor
   212c   37 ad         
   212e   f8 2d bf f8   	load	rf,block0
   2132   9e af         
   2134   f8 04         	ldi	O_APPND		; flags for open, append
   2136   a7            	plo	r7
   2137   d4 03 06      	call	O_OPEN		; attempt to open file to determine size
   213a   cb 21 64      	lbnf	B0opened	; jump if file was opened
   213d   d4 03 4b      	call	O_INMSG
   2140   43 6f 75 6c   	db	'Couldn',27h,'t open file: ',0
   2144   64 6e 27 74   
   2148   20 6f 70 65   
   214c   6e 20 66 69   
   2150   6c 65 3a 20   
   2154   00            
   2155   f8 2d bf f8   	load	rf,block0
   2159   9e af         
   215b   d4 03 33      	call	O_MSG		; display it
   215e   d4 25 a8      	call	crlf
   2161   c0 20 e5      	lbr	Exit		; and return to os
                        B0opened:
   2164   f8 20 bd f8   	load	rd,fildes
   2168   37 ad         
   216a   f8 2d bf f8   	load	rf,fileSize
   216e   9a af         
   2170   4d            	lda	rd		; put 32 bit offset into
   2171   b7            	phi	r7		; R7:R8 and fileSize
   2172   5f            	str	rf
   2173   1f            	inc	rf
                        ;
   2174   4d            	lda	rd
   2175   a7            	plo	r7
   2176   5f            	str	rf
   2177   1f            	inc	rf
                        ;
   2178   4d            	lda	rd
   2179   b8            	phi	r8
   217a   5f            	str	rf
   217b   1f            	inc	rf
                        ;
   217c   0d            	ldn	rd
   217d   a8            	plo	r8
   217e   5f            	str	rf
                        ;
   217f   2d            	dec	rd		; restore descriptor
   2180   2d            	dec	rd
   2181   2d            	dec	rd
                        ;
   2182   87 73 97 73   	push	r7
   2186   88 73 98 73   	push	r8
                        ;
   218a   f8 00 b8 f8   	load	r8,0
   218e   00 a8         
   2190   f8 00 b7 f8   	load	r7,0
   2194   00 a7         
   2196   f8 20 bd f8   	load	rd,fildes
   219a   37 ad         
   219c   f8 00 bc f8   	load	rc,0		; rewind file to start
   21a0   00 ac         
   21a2   d4 03 0f      	call	O_SEEK
                        ;
   21a5   60 72 b8 f0   	pop	r8
   21a9   a8            
   21aa   60 72 b7 f0   	pop	r7
   21ae   a7            
   21af   60 72 bf f0   	pop	rf		; restore block ptr
   21b3   af            
   21b4   d4 25 af      	call	uint32_out	; convert number to ascii
   21b7   f8 20         	ldi	' '		; finish file size with space	
   21b9   5f            	str	rf
   21ba   1f            	inc	rf
                        ;
   21bb   8a 73 9a 73   	push	ra
   21bf   8f 73 9f 73   	push	rf
   21c3   f8 e0         	ldi	0e0h		; lba mode
   21c5   b8            	phi	r8
   21c6   f8 20 bf f8   	load	rf,sector+1	; point to dir sector in FILDES
   21ca   41 af         
   21cc   4f            	lda	rf		; retrieve sector
   21cd   a8            	plo	r8
   21ce   4f            	lda	rf
   21cf   b7            	phi	r7
   21d0   4f            	lda	rf
   21d1   a7            	plo	r7
   21d2   f8 2b bf f8   	load	rf,dirbuf	; where to load sector
   21d6   8e af         
   21d8   d4 ff 3c      	call	f_ideread	; call bios to read the sector
                        ;
   21db   f8 20 bf f8   	load	rf,dirofs+1	; need dirent offset
   21df   45 af         
   21e1   0f            	ldn	rf
   21e2   fc 07         	adi	7		; point to date block
   21e4   aa            	plo	ra
   21e5   2f            	dec	rf
   21e6   0f            	ldn	rf
   21e7   7c 00         	adci	0		; propagate carry
   21e9   ba            	phi	ra		; r7 now points to date block
   21ea   8a            	glo	ra		; now point to correct spot in sector buffer
   21eb   fc 8e         	adi	low dirbuf
   21ed   aa            	plo	ra
   21ee   9a            	ghi	ra
   21ef   7c 2b         	adci	high dirbuf
   21f1   ba            	phi	ra
                        ;
   21f2   f8 2d bf f8   	load	rf,year
   21f6   8e af         
   21f8   4a            	lda	ra		; get year/month
   21f9   f6            	shr			; shift high month bit into DF
   21fa   0a            	ldn	ra		; get low bits of month
   21fb   76            	shrc			; shift high bit in
   21fc   f6            	shr			; then shift into position
   21fd   f6            	shr
   21fe   f6            	shr
   21ff   f6            	shr
   2200   1f            	inc	rf
   2201   5f            	str	rf		; store month
   2202   1f            	inc	rf		; point to day storage
   2203   0a            	ldn	ra		; recover day
   2204   fa 1f         	ani	31		; mask for day
   2206   5f            	str	rf		; store day
   2207   2f            	dec	rf
   2208   2f            	dec	rf		; point back to year offset storage
   2209   2a            	dec	ra		; point back to year
   220a   4a            	lda	ra		; get year
   220b   f6            	shr			; shift out high bit of month
   220c   5f            	str	rf		; store year offset from 1972
   220d   1f            	inc	rf
   220e   1f            	inc	rf
   220f   1f            	inc	rf		; point to hours storage
   2210   1a            	inc	ra		; point to time
   2211   0a            	ldn	ra		; retrieve hours
   2212   f6            	shr			; shift to proper position
   2213   f6            	shr
   2214   f6            	shr
   2215   5f            	str	rf		; store hours
   2216   1f            	inc	rf		; point to minutes storage
   2217   4a            	lda	ra		; get minutes
   2218   fa 07         	ani	07h		; strip out hours
   221a   fe            	shl			; shift to needed spot
   221b   fe            	shl
   221c   fe            	shl
   221d   52            	str	r2		; save for combination
   221e   0a            	ldn	ra		; get low bits of minutes
   221f   f6            	shr			; shift into position
   2220   f6            	shr
   2221   f6            	shr
   2222   f6            	shr
   2223   f6            	shr
   2224   f1            	or			; combine with high bites
   2225   5f            	str	rf		; store minutes
   2226   1f            	inc	rf		; point to seconds storage
   2227   0a            	ldn	ra		; get seconds
   2228   fa 1f         	ani	1fh		; strip minutes out
   222a   fe            	shl			; multiply by 2
   222b   5f            	str	rf		; store seconds	
                        ;
   222c   f8 2d bf f8   	load	rf,year		; point back to year
   2230   8e af         
   2232   f8 03 b7 f8   	load	r7,03c2h	; number of seconds
   2236   c2 a7         
   2238   f8 67 b8 f8   	load	r8,6700h	; from Jan 1 1970 to Jan 1 1972
   223c   00 a8         
   223e   0f            	ldn	rf		; year offset from 1972
   223f   a9            	plo	r9
   2240   f8 00         	ldi	0
   2242   b9            	phi	r9		; leap year counter
                        yearLoop:
   2243   89            	glo	r9
   2244   32 71         	bz	yearsDone
   2246   f8 01 ba f8   	load	ra,01e1h	; seconds in a year
   224a   e1 aa         
   224c   f8 33 bb f8   	load	rb,3380h
   2250   80 ab         
   2252   d4 26 6d      	call	add32bits
   2255   99            	ghi	r9
   2256   fa 03         	ani	00000011b
   2258   3a 69         	bnz	notLeapYear
   225a   f8 00 ba f8   	load	ra,0001h	; seconds in the leap day
   225e   01 aa         
   2260   f8 51 bb f8   	load	rb,5180h	; (86400)
   2264   80 ab         
   2266   d4 26 6d      	call	add32bits
                        notLeapYear:
   2269   99            	ghi	r9
   226a   29            	dec	r9
   226b   fc 01         	adi	1
   226d   b9            	phi	r9
   226e   c0 22 43      	lbr	yearLoop
                        yearsDone:
   2271   f8 00 ba f8   	load	ra,0001h	; seconds in a day
   2275   01 aa         
   2277   f8 51 bb f8   	load	rb,5180h	; (86400)
   227b   80 ab         
   227d   4f            	lda	rf		; re-get year
   227e   fa 03         	ani	00000011b	; rc.1 will be 0 if leap year
   2280   bc            	phi	rc		; 
   2281   4f            	lda	rf		; month # (1-12)
   2282   ff 01         	smi	1
   2284   32 a8         	bz	monthsDone
   2286   ac            	plo	rc		; rc.0 is month # -1
   2287   f8 20 bd f8   	load	rd,monthDays
   228b   2b ad         
                        monthsLoop:
   228d   4d            	lda	rd
   228e   a9            	plo	r9		; rb.0 is # days in month
                        monthLoop:
   228f   d4 26 6d      	call	add32bits	; add a day's worth of seconds
   2292   29            	dec	r9		; decrement days left in month
   2293   89            	glo	r9
   2294   ca 22 8f      	lbnz	monthLoop
   2297   9c            	ghi	rc		; leap year?
   2298   3a a2         	bnz	noLeapYearChk
   229a   8d            	glo	rd		; test for February
   229b   ff 2d         	smi	low monthDays+2
   229d   3a a2         	bnz	notFebruary
   229f   d4 26 6d      	call	add32bits	; add in another day in Feb in leap year	
                        noLeapYearChk:
                        notFebruary:
   22a2   8c            	glo	rc
   22a3   ff 01         	smi	1
   22a5   ac            	plo	rc
   22a6   3a 8d         	bnz	monthsLoop
                        monthsDone:
   22a8   4f            	lda	rf		; day of month
   22a9   ff 01         	smi	1
   22ab   32 b5         	bz	domDone
   22ad   a9            	plo	r9
                        domLoop:
   22ae   d4 26 6d      	call	add32bits
   22b1   29            	dec	r9
   22b2   89            	glo	r9
   22b3   3a ae         	bnz	domLoop
                        domDone:
   22b5   f8 00 ba f8   	load	ra,0
   22b9   00 aa         
   22bb   f8 0e bb f8   	load	rb,3600		; seconds in an hour
   22bf   10 ab         
   22c1   4f            	lda	rf
   22c2   32 cc         	bz	hoursDone
   22c4   a9            	plo	r9
                        hoursLoop:
   22c5   d4 26 6d      	call	add32bits
   22c8   29            	dec	r9
   22c9   89            	glo	r9
   22ca   3a c5         	bnz	hoursLoop
                        hoursDone:
   22cc   f8 00 bb f8   	load	rb,60		; seconds in a minute
   22d0   3c ab         
   22d2   4f            	lda	rf
   22d3   c2 22 df      	lbz	minutesDone
   22d6   a9            	plo	r9
                        minutesLoop:
   22d7   d4 26 6d      	call	add32bits
   22da   29            	dec	r9
   22db   89            	glo	r9
   22dc   ca 22 d7      	lbnz	minutesLoop
                        minutesDone:
   22df   0f            	ldn	rf		; get seconds
   22e0   ab            	plo	rb
   22e1   d4 26 6d      	call	add32bits
                        ;
   22e4   60 72 bf f0   	pop	rf		; restore block 0 ptr
   22e8   af            
   22e9   f8 0c         	ldi	'0' shr 2	; convert r7:r8 to octal number
   22eb   b9            	phi	r9		; and add to block 0 string
   22ec   f8 02         	ldi	2		; 2 bits on first digit
   22ee   a9            	plo	r9
   22ef   f8 0b         	ldi	11		; 11 digits in a 32 bit number
   22f1   aa            	plo	ra
                        bitLoop:
   22f2   88            	glo	r8
   22f3   fe            	shl
   22f4   a8            	plo	r8
   22f5   98            	ghi	r8
   22f6   7e            	shlc
   22f7   b8            	phi	r8
   22f8   87            	glo	r7
   22f9   7e            	shlc
   22fa   a7            	plo	r7
   22fb   97            	ghi	r7
   22fc   7e            	shlc
   22fd   b7            	phi	r7
   22fe   99            	ghi	r9
   22ff   7e            	shlc
   2300   29            	dec	r9
   2301   b9            	phi	r9
   2302   89            	glo	r9
   2303   ca 22 f2      	lbnz	bitLoop
   2306   99            	ghi	r9
   2307   5f            	str	rf
   2308   1f            	inc	rf
   2309   f8 06         	ldi	'0' shr 3	; next octal digit setup
   230b   b9            	phi	r9
   230c   f8 03         	ldi	3		; 3 bits for remaining digits
   230e   a9            	plo	r9
   230f   2a            	dec	ra
   2310   8a            	glo	ra
   2311   ca 22 f2      	lbnz	bitLoop
                        ;
   2314   60 72 ba f0   	pop	ra
   2318   aa            
                        ;
   2319   f8 20         	ldi	' '		; finish timestamp with space	
   231b   5f            	str	rf
   231c   1f            	inc	rf
   231d   f8 30         	ldi	'0'		; default file mode to 0
   231f   5f            	str	rf
   2320   5f            	str	rf
                        ;
   2321   d4 24 4a      	call	WaitNAKorCRC
   2324   ff 43         	smi	crc
   2326   c2 23 3a      	lbz	CrcMode
   2329   ff d2         	smi	nak-crc
   232b   c2 23 3c      	lbz	SaveMode
                        SendFileError:
   232e   f8 20 bd f8   	load	rd,fildes
   2332   37 ad         
   2334   d4 03 12      	call	O_CLOSE
   2337   ff 00         	smi	0		; DF=1, error
   2339   d5            	retn
                        CrcMode:
   233a   f8 01         	ldi	1
                        SaveMode:
   233c   a7            	plo	r7
   233d   f8 2d bf f8   	load	rf,blkMode
   2341   99 af         
   2343   87            	glo	r7
   2344   5f            	str	rf
                        ;
                        	 if	debug=0
   2345   f8 25 bf f8   	load	rf,AckedAction
   2349   44 af         
   234b   f8 5c         	ldi	low readne2
   234d   5f            	str	rf
                        	 endi
   234e   f8 2d bf f8   	load	rf,blkNum
   2352   98 af         
   2354   f8 00         	ldi	0
   2356   5f            	str	rf
   2357   f8 2d bf f8   	load	rf,block0
   235b   9e af         
   235d   f8 00 bc f8   	load	rc,128
   2361   80 ac         
   2363   f8 0a         	ldi	10
   2365   a8            	plo	r8
   2366   d4 24 8f      	call	SendBlock	; send file block 0
   2369   c3 23 2e      	lbdf	SendFileError
                        ;
                        	 if	debug
                        	pushd
                        	call	crlf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	popd
                        	 endif
                        ;
   236c   ff 43         	smi	crc
   236e   32 74         	bz	fileSendLoop
   2370   ff d2         	smi	nak-crc
   2372   3a 2e         	bnz	SendFileError
                        ;
                        FileSendLoop:
   2374   f8 2d bf f8   	load	rf,fileSize
   2378   9a af         
   237a   f8 04 bc f8   	load	rc,1024		; assume we've got at least 1K
   237e   00 ac         
   2380   4f            	lda	rf		; left to send
   2381   ca 23 9c      	lbnz	MoreToGo
   2384   4f            	lda	rf
   2385   ca 23 9c      	lbnz	MoreToGo
   2388   0f            	ldn	rf
   2389   ff 04         	smi	high 1024
   238b   c3 23 9c      	lbdf	MoreToGo	; jump if >= 1K left to go
                        NearingTheEnd:
   238e   f8 00 bc f8   	load	rc,128		; switch to 128 byte sectors
   2392   80 ac         
   2394   4f            	lda	rf
   2395   ca 23 9c      	lbnz	MoreToGo
   2398   0f            	ldn	rf
   2399   c2 24 01      	lbz	FileDone
                        MoreToGo:
   239c   8c 73 9c 73   	push	rc
   23a0   f8 20 bd f8   	load	rd,fildes
   23a4   37 ad         
   23a6   f8 2e bf f8   	load	rf,blockBuffer
   23aa   1e af         
   23ac   d4 03 09      	call	O_READ
   23af   8c            	glo	rc
   23b0   ca 23 b7      	lbnz	ReadBytes
   23b3   9c            	ghi	rc
   23b4   c2 23 fc      	lbz	FileDonePop
                        ReadBytes:
   23b7   f8 2d bf f8   	load	rf,fileSize+3	; LSB
   23bb   9d af         
                        ;
   23bd   8c            	glo	rc		; decrement fileSize by
   23be   52            	str	r2		; # bytes read
   23bf   0f            	ldn	rf
   23c0   f7            	sm
   23c1   5f            	str	rf
                        ;
   23c2   2f            	dec	rf
   23c3   9c            	ghi	rc
   23c4   52            	str	r2
   23c5   0f            	ldn	rf
   23c6   77            	smb
   23c7   5f            	str	rf
                        ;
   23c8   2f            	dec	rf
   23c9   0f            	ldn	rf
   23ca   7d 00         	sdbi	0
   23cc   5f            	str	rf
                        ;
   23cd   2f            	dec	rf
   23ce   0f            	ldn	rf
   23cf   7d 00         	sdbi	0
   23d1   5f            	str	rf
                        ;
   23d2   60 72 bc f0   	pop	rc		; retrieve block size
   23d6   ac            
                        	 if	debug=0
   23d7   f8 25 bf f8   	load	rf,AckedAction
   23db   44 af         
   23dd   f8 81         	ldi	low nextBlock
   23df   5f            	str	rf
                        	 endi
   23e0   f8 2e bf f8   	load	rf,blockBuffer
   23e4   1e af         
   23e6   f8 0a         	ldi	10
   23e8   a8            	plo	r8
   23e9   d4 24 8f      	call	SendBlock
   23ec   c3 23 2e      	lbdf	SendFileError
   23ef   ff 06         	smi	ack
   23f1   32 f9         	bz	BlockACKed
   23f3   d4 24 26      	call	Cancel
   23f6   c0 23 2e      	lbr	SendFileError
                        BlockACKed:
   23f9   c0 23 74      	lbr	fileSendLoop
                        FileDonePop:
   23fc   60 72 bc f0   	pop	rc		; discard block size
   2400   ac            
                        FileDone:
   2401   d4 24 76      	call	SendEOT		; signal file done and get response
   2404   ff 06         	smi	ack		; ACK'd?
   2406   ca 23 2e      	lbnz	SendFileError
   2409   f8 20 bd f8   	load	rd,fildes
   240d   37 ad         
   240f   d4 03 12      	call	O_CLOSE
   2412   fc 00         	adi	0		; DF=0, no error
   2414   d5            	retn			; all done!
                        ;
                        ; ***************************************************
                        ; ***** ZeroBlock0: zeroes block 0		*****
                        ; ***************************************************
                        ZeroBlock0:
   2415   f8 2d bf f8   	load	rf,block0
   2419   9e af         
                        ZeroLoop:
   241b   f8 00         	ldi	0
   241d   5f            	str	rf
   241e   1f            	inc	rf
   241f   8f            	glo	rf
   2420   ff 1e         	smi	low (block0+128)
   2422   ca 24 1b      	lbnz	ZeroLoop
   2425   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Cancel: send 8 CANs followed by 8 BSs	*****
                        ; ***************************************************
                        Cancel:
   2426   87 73 97 73   	push	r7
   242a   f8 08         	ldi	8
   242c   a7            	plo	r7
                        cancelLoop:
   242d   f8 18         	ldi	can
   242f   d4 ff 4e      	call	TTYout		; send CAN (^X) 8 times
   2432   27            	dec	r7
   2433   87            	glo	r7
   2434   ca 24 2d      	lbnz	cancelLoop
   2437   f8 08         	ldi	8
   2439   a7            	plo	r7
                        bsLoop:
   243a   f8 08         	ldi	bs		; send BS (^H) 8 times
   243c   d4 ff 4e      	call	TTYout
   243f   27            	dec	r7
   2440   87            	glo	r7
   2441   ca 24 3a      	lbnz	bsLoop
   2444   60 72 b7 f0   	pop	r7
   2448   a7            
   2449   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** WaitNAKorCRC: wait for CRC or NAK char	*****
                        ; ***************************************************
                        WaitNAKorCRC:
                        	 if	debug
                        	ldi	crc
                        	 else	
   244a   d4 ff 06      	call	f_read
   244d   ae            	plo	re
   244e   ff 43         	smi	crc
   2450   32 56         	bz	GotNAKorCRC
   2452   ff d2         	smi	nak-crc
   2454   3a 4a         	bnz	WaitNAKorCRC
                        GotNAKorCRC:
   2456   8e            	glo	re
                        	 endi
   2457   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** GetACK: wait for ACK/NAK or CAN	char	*****
                        ; ***************************************************
                        GetACK:
                        	 if	debug
                        	ldi	ack
                        	 else
   2458   d4 ff 06      	call	f_read		; read response to block sent
                        	 endi
   245b   ae            	plo	re
   245c   ff 06         	smi	ack
   245e   c2 24 6e      	lbz	GotACK		; ACK'd, all good
   2461   ff 0f         	smi	nak-ack
   2463   c2 24 72      	lbz	DidntGetACK	; NAK'd, probably have to resend
   2466   ff 03         	smi	can-nak
   2468   c2 24 72      	lbz	DidntGetACK	; CAN'd, terminating transfer
   246b   c0 24 58      	lbr	GetACK
                        GotACK:
   246e   8e            	glo	re
   246f   fc 00         	adi	0		; DF = 0, ACKed
   2471   d5            	retn
                        DidntGetACK:
   2472   8e            	glo	re
   2473   ff 00         	smi	0		; DF = 1, not ACKed
   2475   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** SendEOT: send EOT, wait for ACK		*****
                        ; ***************************************************
                        SendEOT:
   2476   f8 04         	ldi	eot
   2478   d4 ff 4e      	call	TTYout		; send EOT (^D)
                        	 if	debug
                        	call	crlf
                        	push	rf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	pop	rf
                        	 else
   247b   d4 ff 06      	call	f_read
   247e   ff 06         	smi	ack		; wait for ACK (^F)
   2480   3a 76         	bnz	SendEOT
                        	 endi
   2482   f8 06         	ldi	ack
   2484   d5            	retn
                        ;
                        ; *******************************************
                        ; ***** Send file block	  		*****
                        ; ***** RF - pointer to block		*****
                        ; ***** RC - Block length		*****
                        ; ***** R8 - # retries			*****
                        ; *******************************************
                        ResendBlock:
   2485   60 72 bf f0   	pop	rf
   2489   af            
   248a   60 72 bc f0   	pop	rc
   248e   ac            
                        SendBlock:
   248f   8c 73 9c 73   	push	rc
   2493   8f 73 9f 73   	push	rf
   2497   9c            	ghi	rc		; 1K or 128b block?
   2498   c2 24 a0      	lbz	Send128
   249b   f8 02         	ldi	stx		; 1K
   249d   c0 24 a2      	lbr	SendStart
                        Send128:
   24a0   f8 01         	ldi	soh		; 128b
                        SendStart:
   24a2   d4 ff 4e      	call	TTYout		; SOH/STK
   24a5   f8 2d bd f8   	load	rd,blkNum
   24a9   98 ad         
   24ab   0d            	ldn	rd
   24ac   d4 ff 4e      	call	TTYout		; block #
   24af   0d            	ldn	rd
   24b0   fd ff         	sdi	255
   24b2   d4 ff 4e      	call	TTYout		; NOT block #
                        ;
   24b5   f8 27         	ldi	high crcTableLow
   24b7   b9            	phi	r9
   24b8   f8 28         	ldi	high crcTableHigh
   24ba   bb            	phi	rb
                        ;
   24bb   f8 00 b7 f8   	load	r7,0
   24bf   00 a7         
   24c1   f8 2d bd f8   	load	rd,blkMode
   24c5   99 ad         
   24c7   0d            	ldn	rd		; 0=checksum, 1=CRC
   24c8   c2 24 ea      	lbz	SendWithChecksum
                        ;
                        SendWithCRC:
   24cb   0f            	ldn	rf
   24cc   d4 ff 4e      	call	TTYout		; send data byte
   24cf   4f            	lda	rf		; retrieve again and advance ptr
                        ;
   24d0   52            	str	r2
   24d1   97            	ghi	r7		; j = (crc >> 8) ^ byte
   24d2   f3            	xor
   24d3   a9            	plo	r9
   24d4   ab            	plo	rb
                        ;
   24d5   87            	glo	r7		; crc = (crc << 8) ^ table[j]
   24d6   eb            	sex	rb
   24d7   f3            	xor
   24d8   e2            	sex	r2
   24d9   b7            	phi	r7
   24da   09            	ldn	r9
   24db   a7            	plo	r7
                        ;
   24dc   2c            	dec	rc		; loop while data bytes
   24dd   9c            	ghi	rc		; left to send
   24de   3a cb         	bnz	SendWithCRC
   24e0   8c            	glo	rc
   24e1   3a cb         	bnz	SendWithCRC
                        ;
   24e3   97            	ghi	r7		; send hi byte of CRC
   24e4   d4 ff 4e      	call	TTYout
   24e7   c0 25 00      	lbr	DoLastChar
                        ;
                        SendWithChecksum:
   24ea   4f            	lda	rf
   24eb   52            	str	r2
   24ec   87            	glo	r7
   24ed   f4            	add
   24ee   a7            	plo	r7
   24ef   02            	ldn	r2
   24f0   d4 ff 4e      	call	TTYout		; send data byte
   24f3   2c            	dec	rc
   24f4   9c            	ghi	rc
   24f5   ca 24 ea      	lbnz	SendWithChecksum
   24f8   8c            	glo	rc
   24f9   ca 24 ea      	lbnz	SendWithChecksum
   24fc   c0 25 00      	lbr	DoLastChar
                        ;
                        	page
                        ;
                        ; BIOS calls weren't quite fast enough to catch the ACK and CRC/NAK
                        ; at the end of a block 0 send. They did manage just the ACK at the end
                        ; of a normal block, most of the time. So, reluctantly, I've had to
                        ; inline the bit banged UART code. I've got some ideas about auto
                        ; patching this to match the machine configuration, but it's all in
                        ; my head at the moment.
                        ;
                        DoLastChar:
                        	 if debug
                        	glo	r7
                        	call	ttyout
                        	load	rf,blknum
                        	ldn	rf
                        	adi	1
                        	str	rf
                        	load	rf,hexcount
                        	ldi	0
                        	str	rf
                        	call	O_INMSG
                        	db	'acked',cr,lf,0
                        	pop	rf
                        	pop	rc
                        	ldi	ack
                        	adi	0
                        	retn
                        	 else
   2500   f8 09         	ldi	9		; 9 bits to send
   2502   af            	plo	rf
   2503   f8 25 bd f8   	load	rd,delay	; point RD to delay routine
   2507   9e ad         
   2509   dd            	sep	rd
   250a   dd            	sep	rd
   250b   f8 00         	ldi	0
   250d   f6            	shr
   250e   33 13         typelp:	bdf	typenb		; jump if no bit
   2510   7a            	req			; set output
   2511   30 16         	br	typect
   2513   7b            typenb:	seq			; reset output
   2514   30 16         	br	typect
   2516   dd            typect:	sep	rd		; perform bit delay
   2517   e2            	sex	r2
   2518   e2            	sex	r2
   2519   87            	glo	r7
   251a   76            	shrc
   251b   a7            	plo	r7
   251c   2f            	dec	rf
   251d   8f            	glo	rf
   251e   3a 0e         	bnz	typelp
   2520   7b            	seq			; set stop bits
   2521   dd            	sep	rd		; wait half the pulse width
   2522   dd            	sep	rd		; wait another half the pulse width
                        readne:
   2523   f8 09         	ldi	9		; 8 bits to receive
   2525   af            	plo	rf
   2526   9e            	ghi	re		; first delay is half bit size
   2527   bf            	phi	rf
   2528   f6            	shr
   2529   f6            	shr
   252a   be            	phi	re
   252b   3d 2b         	bn2	$		; wait for transmission
   252d   dd            	sep	rd		; wait half the pulse width
   252e   9f            	ghi	rf		; recover baud constant
   252f   be            	phi	re
                        recvnelp:
   2530   9f            	ghi	rf
   2531   f6            	shr			; shift right
   2532   35 99         	b2	recvnelp0	; jump if zero bi
   2534   f9 80         	ori	128		; set bit
                        recvnelp1:
   2536   bf            	phi	rf
   2537   dd            	sep	rd		; perform bit delay
   2538   2f            	dec	rf		; decrement bit count
   2539   c4            	nop
   253a   c4            	nop
   253b   8f            	glo	rf		; check for zero
   253c   3a 30         	bnz	recvnelp	; loop if not
                        recvnedn:
   253e   dd            	sep	rd
   253f   9f            	ghi	rf		; get character
   2540   ae            	plo	re
                        
   2541   ff 06         	smi	ack
                        AckedAction equ	$+1
   2543   32 5c         	bz	readne2		; block ACK'd
   2545   ff 0f         	smi	nak-ack
   2547   3a 4e         	bnz	SendBlockError
   2549   28            	dec	r8		; block NAK'd
   254a   88            	glo	r8		; resend if any retries left
   254b   ca 24 85      	lbnz	ResendBlock
                        SendBlockError:
   254e   60 72 bf f0   	pop	rf
   2552   af            
   2553   60 72 bc f0   	pop	rc
   2557   ac            
   2558   8e            	glo	re
   2559   ff 00         	smi	0		; DF = 1, error
   255b   d5            	retn
                        readne2:
   255c   f8 09         	ldi	9		; 8 bits to receive
   255e   af            	plo	rf
   255f   9e            	ghi	re		; first delay is half bit size
   2560   bf            	phi	rf
   2561   f6            	shr
   2562   f6            	shr
   2563   be            	phi	re
   2564   3d 64         	bn2	$		; wait for transmission
   2566   dd            	sep	rd		; wait half the pulse width
   2567   9f            	ghi	rf		; recover baud constant
   2568   be            	phi	re
                        recvne2lp:
   2569   9f            	ghi	rf
   256a   f6            	shr			; shift right
   256b   35 9b         	b2	recvne2lp0	; jump if zero bi
   256d   f9 80         	ori	128		; set bit
                        recvne2lp1:
   256f   bf            	phi	rf
   2570   dd            	sep	rd		; perform bit delay
   2571   2f            	dec	rf		; decrement bit count
   2572   c4            	nop
   2573   c4            	nop
   2574   8f            	glo	rf		; check for zero
   2575   3a 69         	bnz	recvne2lp	; loop if not
                        recvne2dn:
   2577   9f            	ghi	rf		; get character
   2578   ae            	plo	re
   2579   ff 43         	smi	crc
   257b   32 81         	bz	nextBlock
   257d   ff d2         	smi	nak-crc
   257f   3a 4e         	bnz	SendBlockError
                        nextBlock:
   2581   f8 2d bf f8   	load	rf,blkNum
   2585   98 af         
   2587   0f            	ldn	rf
   2588   fc 01         	adi	1
   258a   5f            	str	rf
   258b   60 72 bf f0   	pop	rf
   258f   af            
   2590   60 72 bc f0   	pop	rc
   2594   ac            
   2595   8e            	glo	re
   2596   fc 00         	adi	0		; DF = 0, ok
   2598   d5            	retn
                        recvnelp0:
   2599   30 36         	br	recvnelp1	; equalize between 0 and 1
                        recvne2lp0:
   259b   30 6f         	br	recvne2lp1	; equalize between 0 and 1
                        ;
   259d   d3            delayX:	sep	r3
   259e   9e            delay:	ghi	re		; get baud constant
   259f   f6            	shr			; remove echo flag
   25a0   ae            	plo	re		; put into counter
   25a1   e2            	sex	r2		; waste a cycle
   25a2   2e            delay1:	dec	re		; decrement counter
   25a3   8e            	glo	re		; get count
   25a4   32 9d         	bz	delayX		; return if zero
   25a6   30 a2         	br	delay1		; otherwise keep going
                        	 endi
                        ;
                        ; ***************************************************
                        ; ***** Start a new line on the terminal	*****
                        ; ***************************************************
                        crlf:
   25a8   d4 03 4b      	call	O_INMSG
   25ab   0d 0a 00      	db	cr,lf,0
   25ae   d5            	retn
                        ;
                        ; ***************************************************
                        ; ***** Convert 32-bit unsigned int to ASCII	*****
                        ; ***** using the double-dabble algorithm	*****
                        ; ***** (AKA shift and add 3)			*****
                        ; ***** R7:R8 - 32-bit integer			*****
                        ; ***** RF - destination buffer	pointer		*****
                        ; ***************************************************
                        UINT32_DIGITS	EQU	10	; maximum of 10 digits in result
                        UINT32_BITS	EQU	32	; how many bits did you THINK there'd be???
                        
                        uint32_out:
   25af   8d 73 9d 73   	push	rd		; save consumed registers
   25b3   89 73 99 73   	push	r9
   25b7   88 73 98 73   	push	r8
   25bb   87 73 97 73   	push	r7
   25bf   f8 2b bd f8   	load	rd,uint32_buf	; RD is output buffer
   25c3   00 ad         
                        itoa1:	
   25c5   8d 73 9d 73   	push	rd		; save buffer pointer
   25c9   f8 0a         	ldi	UINT32_DIGITS	; clear out BCD buffer
   25cb   ae            	plo	re
                        tobcdlp1:
   25cc   f8 00         	ldi	0
   25ce   5d            	str	rd		; store into answer
   25cf   1d            	inc	rd
   25d0   2e            	dec	re		; decrement count
   25d1   8e            	glo	re
   25d2   ca 25 cc      	lbnz	tobcdlp1	; loop until done
   25d5   60 72 bd f0   	pop	rd		; recover buffer pointer
   25d9   ad            
   25da   f8 20         	ldi	UINT32_BITS	; 32 bits to process
   25dc   a9            	plo	r9
                        tobcdlp2:
   25dd   f8 0a         	ldi	UINT32_DIGITS	; process all 10 digits
   25df   ae            	plo	re		; for digits >= 5
   25e0   8d 73 9d 73   	push	rd		; save buffer pointer
                        tobcdlp3:
   25e4   0d            	ldn	rd		; get byte
   25e5   ff 05         	smi	5		; need to see if 5 or greater
   25e7   cb 25 ed      	lbnf	tobcdlp3a	; jump if not
   25ea   fc 08         	adi	5+3		; add 3 to original number
   25ec   5d            	str	rd		; and put it back
                        tobcdlp3a:
   25ed   1d            	inc	rd		; point to next cell
   25ee   2e            	dec	re		; decrement cell count
   25ef   8e            	glo	re		; retrieve count
   25f0   ca 25 e4      	lbnz	tobcdlp3	; loop back if not done
                        	
   25f3   88            	glo	r8		; shift 32 bit binary number
   25f4   fe            	shl			; 1 bit left
   25f5   a8            	plo	r8
   25f6   98            	ghi	r8
   25f7   7e            	shlc
   25f8   b8            	phi	r8
   25f9   87            	glo	r7
   25fa   7e            	shlc
   25fb   a7            	plo	r7
   25fc   97            	ghi	r7
   25fd   7e            	shlc
   25fe   b7            	phi	r7
                        	
   25ff   7e            	shlc			; now shift result to bit 3
   2600   fe            	shl
   2601   fe            	shl
   2602   fe            	shl
   2603   5d            	str	rd
   2604   60 72 bd f0   	pop	rd		; recover address
   2608   ad            
   2609   8d 73 9d 73   	push	rd		; save address again
   260d   f8 0a         	ldi	UINT32_DIGITS	; 10 BCD digits to process
   260f   ae            	plo	re
                        tobcdlp4:
   2610   4d            	lda	rd		; get current cell
   2611   52            	str	r2		; save it
   2612   0d            	ldn	rd		; get next cell
   2613   f6            	shr			; shift bit 3 into df
   2614   f6            	shr
   2615   f6            	shr
   2616   f6            	shr
   2617   02            	ldn	r2		; recover value for current cell
   2618   7e            	shlc			; shift with new bit
   2619   fa 0f         	ani	00001111b	; keep only bottom 4 bits
   261b   2d            	dec	rd		; point back
   261c   5d            	str	rd		; store value
   261d   1d            	inc	rd		; and move to next cell
   261e   2e            	dec	re		; decrement count
   261f   8e            	glo	re		; see if done
   2620   ca 26 10      	lbnz	tobcdlp4	; jump if not
   2623   60 72 bd f0   	pop	rd		; recover address
   2627   ad            
   2628   29            	dec	r9		; decrement bit count
   2629   89            	glo	r9		; see if done
   262a   ca 25 dd      	lbnz	tobcdlp2	; loop until done
                        ;
   262d   f8 2b bd f8   	load	rd,uint32_buf
   2631   00 ad         
   2633   f8 0a         	ldi	UINT32_DIGITS
   2635   a8            	plo	r8
   2636   f8 09         	ldi	UINT32_DIGITS-1	; max 9 leading zeros
   2638   b8            	phi	r8
   2639   4d            loop1:	lda	rd
   263a   c2 26 63      	lbz	uint32outz	; check leading zeros
   263d   52            	str	r2		; save for a moment
   263e   f8 00         	ldi	0		; signal no more leading zeros
   2640   b8            	phi	r8
   2641   02            	ldn	r2		; recover character
   2642   fc 30         itoa2:	adi	'0'
   2644   5f            	str	rf		; store into output buffer
   2645   1f            	inc	rf
   2646   28            itoa3:	dec	r8
   2647   88            	glo	r8
   2648   ca 26 39      	lbnz	loop1
   264b   f8 00         	ldi	0		; place terminator in destination
   264d   5f            	str	rf
   264e   60 72 b7 f0   	pop	r7
   2652   a7            
   2653   60 72 b8 f0   	pop	r8		; recover consumed registers
   2657   a8            
   2658   60 72 b9 f0   	pop	r9
   265c   a9            
   265d   60 72 bd f0   	pop	rd
   2661   ad            
   2662   d5            	retn			; return to caller
                        
                        uint32outz:
   2663   98            	ghi	r8		; see if leading have been used up
   2664   c2 26 42      	lbz	itoa2		; jump if so
   2667   ff 01         	smi	1		; decrement count
   2669   b8            	phi	r8
   266a   c0 26 46      	lbr	itoa3		; and loop for next character
                        ;
                        ; ***************************************************
                        ; ***** add32bits: r7:r8 = r7:r8 + ra:rb	*****
                        ; ***************************************************
                        add32bits:
   266d   8b            	glo	rb
   266e   52            	str	r2
   266f   88            	glo	r8
   2670   f4            	add
   2671   a8            	plo	r8
   2672   9b            	ghi	rb
   2673   52            	str	r2
   2674   98            	ghi	r8
   2675   74            	adc
   2676   b8            	phi	r8
   2677   8a            	glo	ra
   2678   52            	str	r2
   2679   87            	glo	r7
   267a   74            	adc
   267b   a7            	plo	r7
   267c   9a            	ghi	ra
   267d   52            	str	r2
   267e   97            	ghi	r7
   267f   74            	adc
   2680   b7            	phi	r7
   2681   d5            	retn
                        ;
                        	 if	debug
                        ;
                        ; ***************************************************
                        ; ***** Debug output routine			*****
                        ; ***************************************************
                        TTYout:
                        	plo	re
                        	push	re
                        	push	rf
                        	push	rd
                        	load	rf,hexbuf
                        	ldi	0
                        	phi	rd
                        	glo	re
                        	plo	rd
                        	call	f_hexout2
                        	ldi	' '
                        	str	rf
                        	inc	rf
                        	ldi	0
                        	str	rf
                        	load	rf,hexbuf
                        	call	O_MSG
                        	load	rd,hexcount
                        	ldn	rd
                        	adi	1
                        	str	rd
                        	smi	16
                        	lbnz	NotEOL
                        	str	rd
                        	call	crlf
                        NotEOL:
                        	pop	rd
                        	pop	rf
                        	pop	re
                        	retn
                        hexbuf:	ds	4
                        hexcount:
                        	db	0
                        	retn
                        ;
                        	 else
                        ;
                        TTYout	equ	f_tty		; non debug output routine
                        ;
                        	 endi
                        ;
                        	page			; The CRC tables must be page aligned
                        ;
                        crcTableLow:
   2700   00 21 42 63   	db	000h,021h,042h,063h,084h,0a5h,0c6h,0e7h
   2704   84 a5 c6 e7   
   2708   08 29 4a 6b   	db	008h,029h,04ah,06bh,08ch,0adh,0ceh,0efh
   270c   8c ad ce ef   
   2710   31 10 73 52   	db	031h,010h,073h,052h,0b5h,094h,0f7h,0d6h
   2714   b5 94 f7 d6   
   2718   39 18 7b 5a   	db	039h,018h,07bh,05ah,0bdh,09ch,0ffh,0deh
   271c   bd 9c ff de   
   2720   62 43 20 01   	db	062h,043h,020h,001h,0e6h,0c7h,0a4h,085h
   2724   e6 c7 a4 85   
   2728   6a 4b 28 09   	db	06ah,04bh,028h,009h,0eeh,0cfh,0ach,08dh
   272c   ee cf ac 8d   
   2730   53 72 11 30   	db	053h,072h,011h,030h,0d7h,0f6h,095h,0b4h
   2734   d7 f6 95 b4   
   2738   5b 7a 19 38   	db	05bh,07ah,019h,038h,0dfh,0feh,09dh,0bch
   273c   df fe 9d bc   
   2740   c4 e5 86 a7   	db	0c4h,0e5h,086h,0a7h,040h,061h,002h,023h
   2744   40 61 02 23   
   2748   cc ed 8e af   	db	0cch,0edh,08eh,0afh,048h,069h,00ah,02bh
   274c   48 69 0a 2b   
   2750   f5 d4 b7 96   	db	0f5h,0d4h,0b7h,096h,071h,050h,033h,012h
   2754   71 50 33 12   
   2758   fd dc bf 9e   	db	0fdh,0dch,0bfh,09eh,079h,058h,03bh,01ah
   275c   79 58 3b 1a   
   2760   a6 87 e4 c5   	db	0a6h,087h,0e4h,0c5h,022h,003h,060h,041h
   2764   22 03 60 41   
   2768   ae 8f ec cd   	db	0aeh,08fh,0ech,0cdh,02ah,00bh,068h,049h
   276c   2a 0b 68 49   
   2770   97 b6 d5 f4   	db	097h,0b6h,0d5h,0f4h,013h,032h,051h,070h
   2774   13 32 51 70   
   2778   9f be dd fc   	db	09fh,0beh,0ddh,0fch,01bh,03ah,059h,078h
   277c   1b 3a 59 78   
   2780   88 a9 ca eb   	db	088h,0a9h,0cah,0ebh,00ch,02dh,04eh,06fh
   2784   0c 2d 4e 6f   
   2788   80 a1 c2 e3   	db	080h,0a1h,0c2h,0e3h,004h,025h,046h,067h
   278c   04 25 46 67   
   2790   b9 98 fb da   	db	0b9h,098h,0fbh,0dah,03dh,01ch,07fh,05eh
   2794   3d 1c 7f 5e   
   2798   b1 90 f3 d2   	db	0b1h,090h,0f3h,0d2h,035h,014h,077h,056h
   279c   35 14 77 56   
   27a0   ea cb a8 89   	db	0eah,0cbh,0a8h,089h,06eh,04fh,02ch,00dh
   27a4   6e 4f 2c 0d   
   27a8   e2 c3 a0 81   	db	0e2h,0c3h,0a0h,081h,066h,047h,024h,005h
   27ac   66 47 24 05   
   27b0   db fa 99 b8   	db	0dbh,0fah,099h,0b8h,05fh,07eh,01dh,03ch
   27b4   5f 7e 1d 3c   
   27b8   d3 f2 91 b0   	db	0d3h,0f2h,091h,0b0h,057h,076h,015h,034h
   27bc   57 76 15 34   
   27c0   4c 6d 0e 2f   	db	04ch,06dh,00eh,02fh,0c8h,0e9h,08ah,0abh
   27c4   c8 e9 8a ab   
   27c8   44 65 06 27   	db	044h,065h,006h,027h,0c0h,0e1h,082h,0a3h
   27cc   c0 e1 82 a3   
   27d0   7d 5c 3f 1e   	db	07dh,05ch,03fh,01eh,0f9h,0d8h,0bbh,09ah
   27d4   f9 d8 bb 9a   
   27d8   75 54 37 16   	db	075h,054h,037h,016h,0f1h,0d0h,0b3h,092h
   27dc   f1 d0 b3 92   
   27e0   2e 0f 6c 4d   	db	02eh,00fh,06ch,04dh,0aah,08bh,0e8h,0c9h
   27e4   aa 8b e8 c9   
   27e8   26 07 64 45   	db	026h,007h,064h,045h,0a2h,083h,0e0h,0c1h
   27ec   a2 83 e0 c1   
   27f0   1f 3e 5d 7c   	db	01fh,03eh,05dh,07ch,09bh,0bah,0d9h,0f8h
   27f4   9b ba d9 f8   
   27f8   17 36 55 74   	db	017h,036h,055h,074h,093h,0b2h,0d1h,0f0h
   27fc   93 b2 d1 f0   
                        ;
                        crcTableHigh:
   2800   00 10 20 30   	db	000h,010h,020h,030h,040h,050h,060h,070h
   2804   40 50 60 70   
   2808   81 91 a1 b1   	db	081h,091h,0a1h,0b1h,0c1h,0d1h,0e1h,0f1h
   280c   c1 d1 e1 f1   
   2810   12 02 32 22   	db	012h,002h,032h,022h,052h,042h,072h,062h
   2814   52 42 72 62   
   2818   93 83 b3 a3   	db	093h,083h,0b3h,0a3h,0d3h,0c3h,0f3h,0e3h
   281c   d3 c3 f3 e3   
   2820   24 34 04 14   	db	024h,034h,004h,014h,064h,074h,044h,054h
   2824   64 74 44 54   
   2828   a5 b5 85 95   	db	0a5h,0b5h,085h,095h,0e5h,0f5h,0c5h,0d5h
   282c   e5 f5 c5 d5   
   2830   36 26 16 06   	db	036h,026h,016h,006h,076h,066h,056h,046h
   2834   76 66 56 46   
   2838   b7 a7 97 87   	db	0b7h,0a7h,097h,087h,0f7h,0e7h,0d7h,0c7h
   283c   f7 e7 d7 c7   
   2840   48 58 68 78   	db	048h,058h,068h,078h,008h,018h,028h,038h
   2844   08 18 28 38   
   2848   c9 d9 e9 f9   	db	0c9h,0d9h,0e9h,0f9h,089h,099h,0a9h,0b9h
   284c   89 99 a9 b9   
   2850   5a 4a 7a 6a   	db	05ah,04ah,07ah,06ah,01ah,00ah,03ah,02ah
   2854   1a 0a 3a 2a   
   2858   db cb fb eb   	db	0dbh,0cbh,0fbh,0ebh,09bh,08bh,0bbh,0abh
   285c   9b 8b bb ab   
   2860   6c 7c 4c 5c   	db	06ch,07ch,04ch,05ch,02ch,03ch,00ch,01ch
   2864   2c 3c 0c 1c   
   2868   ed fd cd dd   	db	0edh,0fdh,0cdh,0ddh,0adh,0bdh,08dh,09dh
   286c   ad bd 8d 9d   
   2870   7e 6e 5e 4e   	db	07eh,06eh,05eh,04eh,03eh,02eh,01eh,00eh
   2874   3e 2e 1e 0e   
   2878   ff ef df cf   	db	0ffh,0efh,0dfh,0cfh,0bfh,0afh,09fh,08fh
   287c   bf af 9f 8f   
   2880   91 81 b1 a1   	db	091h,081h,0b1h,0a1h,0d1h,0c1h,0f1h,0e1h
   2884   d1 c1 f1 e1   
   2888   10 00 30 20   	db	010h,000h,030h,020h,050h,040h,070h,060h
   288c   50 40 70 60   
   2890   83 93 a3 b3   	db	083h,093h,0a3h,0b3h,0c3h,0d3h,0e3h,0f3h
   2894   c3 d3 e3 f3   
   2898   02 12 22 32   	db	002h,012h,022h,032h,042h,052h,062h,072h
   289c   42 52 62 72   
   28a0   b5 a5 95 85   	db	0b5h,0a5h,095h,085h,0f5h,0e5h,0d5h,0c5h
   28a4   f5 e5 d5 c5   
   28a8   34 24 14 04   	db	034h,024h,014h,004h,074h,064h,054h,044h
   28ac   74 64 54 44   
   28b0   a7 b7 87 97   	db	0a7h,0b7h,087h,097h,0e7h,0f7h,0c7h,0d7h
   28b4   e7 f7 c7 d7   
   28b8   26 36 06 16   	db	026h,036h,006h,016h,066h,076h,046h,056h
   28bc   66 76 46 56   
   28c0   d9 c9 f9 e9   	db	0d9h,0c9h,0f9h,0e9h,099h,089h,0b9h,0a9h
   28c4   99 89 b9 a9   
   28c8   58 48 78 68   	db	058h,048h,078h,068h,018h,008h,038h,028h
   28cc   18 08 38 28   
   28d0   cb db eb fb   	db	0cbh,0dbh,0ebh,0fbh,08bh,09bh,0abh,0bbh
   28d4   8b 9b ab bb   
   28d8   4a 5a 6a 7a   	db	04ah,05ah,06ah,07ah,00ah,01ah,02ah,03ah
   28dc   0a 1a 2a 3a   
   28e0   fd ed dd cd   	db	0fdh,0edh,0ddh,0cdh,0bdh,0adh,09dh,08dh
   28e4   bd ad 9d 8d   
   28e8   7c 6c 5c 4c   	db	07ch,06ch,05ch,04ch,03ch,02ch,01ch,00ch
   28ec   3c 2c 1c 0c   
   28f0   ef ff cf df   	db	0efh,0ffh,0cfh,0dfh,0afh,0bfh,08fh,09fh
   28f4   af bf 8f 9f   
   28f8   6e 7e 4e 5e   	db	06eh,07eh,04eh,05eh,02eh,03eh,00eh,01eh
   28fc   2e 3e 0e 1e   
                        ;
                        Dta:		ds	512
                        uint32_buf:	ds	UINT32_DIGITS+1	
                        		ds	128
                        localStack:	ds	1
                        saveStack:	ds	2
                        
                        dirbuf:	ds	512
                        ;
                        year:	ds	1
                        month:	ds	1
                        dom:	ds	1
                        hours:	ds	1
                        minutes: ds	1
                        seconds: ds	1
                        ;
                        epoch:	ds	4
                        ;
                        blkNum:		ds	1		; current block #
                        blkMode:	ds	1		; 0=checksum, 1=CRC
                        fileSize:	ds	4		; # bytes remaining in file
                        block0:		ds	128		; buffer for tx/rx
                        blockBuffer:	ds	512
                        ;
                        endrom	equ	$
                        ;
                        	end
0006  ack           2544  AckedAction    266d  add32bits     2116  B0loop1   
2164  B0opened      0004  b_devBBSER    0002  b_devFLPY     0001  b_devIDE  
0020  b_devNVR      0010  b_devRTC      0008  b_devUART     ff00  BIOS      
22f2  bitLoop       2d99  blkMode       2d98  blkNum        2d9e  block0    
23f9  BlockACKed    2e1e  blockBuffer    0008  bs            243a  bsLoop    
2006  Build         0018  can           2426  Cancel        242d  cancelLoop
000d  cr            0043  crc           233a  CrcMode       2800  crcTableHigh
2700  crcTableLow    25a8  crlf          0000  debug         259e  delay     
25a2  delay1        259d  delayX        2472  DidntGetACK    2b8e  dirbuf    
2044  dirofs        2500  DoLastChar    2d90  dom           22b5  domDone   
22ae  domLoop       2900  Dta           f800  EBIOS         301e  endrom    
0004  eot           2d94  epoch         0005  errdirnotempty    0001  errexists 
0003  errinvdir     0004  errisdir      0002  errnoffnd     0006  errnotexec
20e5  Exit          2107  Exit2         f830  f_astodt      f833  f_astotm  
ff5d  f_atoi        ff00  f_boot        ff42  f_bootide     f800  f_bread   
ff6c  f_brktest     f806  f_btest       f803  f_btype       ff33  f_div16   
ff2a  f_drive       f827  f_dttoas      ff6f  f_findtkn     ff57  f_freemem 
ff81  f_getdev      f815  f_gettod      ff45  f_hexin       ff48  f_hexout2 
ff4b  f_hexout4     f824  f_ideid       ff3c  f_ideread     ff36  f_idereset
f821  f_idesize     ff39  f_idewrite    ff7b  f_idnum       ff3f  f_initcall
ff66  f_inmsg       ff0f  f_input       ff69  f_inputl      ff63  f_intout  
ff78  f_isalnum     ff72  f_isalpha     ff75  f_ishex       ff5a  f_isnum   
ff7e  f_isterm      ff15  f_ltrim       ff1b  f_memcpy      ff54  f_minimon 
ff51  f_mover       ff09  f_msg         ff30  f_mul16       f836  f_nvrcchk 
f81b  f_rdnvr       ff21  f_rdsec       ff06  f_read        f82d  f_rtctest 
ff27  f_seek        ff24  f_seek0       ff2d  f_setbd       f818  f_settod  
ff12  f_strcmp      ff18  f_strcpy      f82a  f_tmtoas      ff4e  f_tty     
ff03  f_type        ff0c  f_typex       ff60  f_uintout     f80c  f_uread   
f812  f_usetbd      f80f  f_utest       f809  f_utype       fff9  f_version 
f81e  f_wrnvr       ff1e  f_wrtsec      2037  FilDes        2401  FileDone  
23fc  FileDonePop    2374  FileSendLoop    2d9a  fileSize      2458  GetACK    
246e  GotACK        2456  GotNAKorCRC    2d91  hours         22cc  hoursDone 
22c5  hoursLoop     03f6  I_SERVE       25c5  itoa1         2642  itoa2     
2646  itoa3         0406  K_BDAY        0405  K_BMONTH      0403  K_BUILD   
0407  K_BYEAR       0470  K_CLKFREQ     0476  K_DAY         0468  K_HEAP    
0442  K_HIMEM       0478  K_HOUR        0465  K_LOWMEM      0479  K_MINUTE  
0475  K_MONTH       0467  K_RETVAL      047b  K_SECDEN      047d  K_SECNUM  
047a  K_SECOND      0400  K_VER         0477  K_YEAR        000a  lf        
2000  LoadAdr       2b8b  localStack    2639  loop1         2d92  minutes   
22df  minutesDone    22d7  minutesLoop    2d8f  month         202b  monthDays 
228f  monthLoop     22a8  monthsDone    228d  monthsLoop    239c  MoreToGo  
0015  nak           238e  NearingTheEnd    2581  nextBlock     20a6  NextFile  
20dc  NextFileName    22a2  noLeapYearChk    22a2  notFebruary    2269  notLeapYear
036c  O_ALLOC       0004  O_APPND       035a  O_BOOT        0366  O_BRKTEST 
0324  O_CHDIR       0300  O_CLDBOOT     0312  O_CLOSE       0001  O_CREAT   
0475  O_DATTIM      036f  O_DEALLOC     0318  O_DELETE      0369  O_DEVCTRL 
031e  O_EXEC        0342  O_EXECBIN     034e  O_GETDEV      0351  O_GETTOD  
0363  O_INITCALL    034b  O_INMSG       0339  O_INPUT       0357  O_INPUTL  
0348  O_KINIT       0375  O_MEMCTRL     0321  O_MKDIR       0333  O_MSG     
0306  O_OPEN        0315  O_OPENDIR     033f  O_PRINT       033c  O_PRTSTAT 
032a  O_RDLUMP      0309  O_READ        0336  O_READKEY     031b  O_RENAME  
0327  O_RMDIR       030f  O_SEEK        0360  O_SETBD       0345  O_SETDEF  
0354  O_SETTOD      0372  O_TERMCTRL    0002  O_TRUNC       0330  O_TYPE    
030c  O_WRITE       032d  O_WRLUMP      0303  O_WRMBOOT     0000  r0        
0001  r1            000a  r10           000b  r11           000c  r12       
000d  r13           000e  r14           000f  r15           0002  r2        
0003  r3            0004  r4            0005  r5            0006  r6        
0007  r7            0008  r8            0009  r9            000a  ra        
000b  rb            000c  rc            000d  rd            000e  re        
23b7  ReadBytes     2523  readne        255c  readne2       2577  recvne2dn 
2569  recvne2lp     259b  recvne2lp0    256f  recvne2lp1    253e  recvnedn  
2530  recvnelp      2599  recvnelp0     2536  recvnelp1     2485  ResendBlock
000f  rf            233c  SaveMode      2b8c  saveStack     0004  scall     
2d93  seconds       2040  sector        24a0  Send128       248f  SendBlock 
254e  SendBlockError    2476  SendEOT       210d  SendFile      232e  SendFileError
24a2  SendStart     24ea  SendWithChecksum    24cb  SendWithCRC    0001  soh       
0005  sret          204a  start         2073  start2        0002  stx       
25cc  tobcdlp1      25dd  tobcdlp2      25e4  tobcdlp3      25ed  tobcdlp3a 
2610  tobcdlp4      ff4e  TTYout        2516  typect        250e  typelp    
2513  typenb        0020  UINT32_BITS    2b00  uint32_buf    000a  UINT32_DIGITS
25af  uint32_out    2663  uint32outz    036a  V_DVEC        03fd  V_IVEC    
244a  WaitNAKorCRC    2d8e  year          2243  yearLoop      2271  yearsDone 
2415  ZeroBlock0    241b  ZeroLoop      
